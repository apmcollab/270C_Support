<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>270C_Support: SCC::SparseOp&lt; Vtype &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">270C_Support
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">Supporting C++ Classes For Math 270</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_s_c_c.html">SCC</a></li><li class="navelem"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_s_c_c_1_1_sparse_op-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SCC::SparseOp&lt; Vtype &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Sparse matrix representation of finite dimensional linear operators.  
 <a href="class_s_c_c_1_1_sparse_op.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01ca58371ec3964c4d6dcc3859762c14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a01ca58371ec3964c4d6dcc3859762c14">SparseOp</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;S)</td></tr>
<tr class="separator:a01ca58371ec3964c4d6dcc3859762c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418fd46311c8bbb3162c8e10b1169ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a8418fd46311c8bbb3162c8e10b1169ad">SparseOp</a> (long rowDimension, long colDimension, double dropTolerance=0.0)</td></tr>
<tr class="separator:a8418fd46311c8bbb3162c8e10b1169ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff49d597cf2083f4f60ba5d29fb3380"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a3ff49d597cf2083f4f60ba5d29fb3380">SparseOp</a> (long rowDimension, long colDimension, long initialRowSize, double rowExpansionFactor, double dropTolerance=0.0)</td></tr>
<tr class="separator:a3ff49d597cf2083f4f60ba5d29fb3380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4831fb0ad84a6c7fb584cbc244c1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#afd4831fb0ad84a6c7fb584cbc244c1b7">initialize</a> ()</td></tr>
<tr class="separator:afd4831fb0ad84a6c7fb584cbc244c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0a4d9e56c38c04c8c5e5b36fdf118b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a2e0a4d9e56c38c04c8c5e5b36fdf118b">initialize</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;S)</td></tr>
<tr class="separator:a2e0a4d9e56c38c04c8c5e5b36fdf118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10af7915f2a748a77805ede9690e821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ac10af7915f2a748a77805ede9690e821">initialize</a> (long rowDimension, long colDimension, double dropTolerance=0.0)</td></tr>
<tr class="separator:ac10af7915f2a748a77805ede9690e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa551d2cdbb27e5bb74a71cbf67583489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#aa551d2cdbb27e5bb74a71cbf67583489">initialize</a> (long rowDimension, long colDimension, long initialRowSize, double rowExpansionFactor, double dropTolerance=0.0)</td></tr>
<tr class="separator:aa551d2cdbb27e5bb74a71cbf67583489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356ea3d7ee3a49823210af278eccfa44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a356ea3d7ee3a49823210af278eccfa44">assumedUniqueSetOperatorData</a> (long rowIndex, long colIndex, double coeffValue)</td></tr>
<tr class="separator:a356ea3d7ee3a49823210af278eccfa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32ee661ce89c4d6cc0e91c05133fced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ab32ee661ce89c4d6cc0e91c05133fced">setOperatorData</a> (long rowIndex, long colIndex, double coeffValue)</td></tr>
<tr class="separator:ab32ee661ce89c4d6cc0e91c05133fced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa257b6414b35a3a8f44a03c85e656db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_c_1_1_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#aa257b6414b35a3a8f44a03c85e656db9">operator()</a> (long i, long j)</td></tr>
<tr class="separator:aa257b6414b35a3a8f44a03c85e656db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13543ef5c72570ede29381d913c3e80b"><td class="memItemLeft" align="right" valign="top"><a id="a13543ef5c72570ede29381d913c3e80b"></a>
const <a class="el" href="class_s_c_c_1_1_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator()</b> (long i, long j) const</td></tr>
<tr class="separator:a13543ef5c72570ede29381d913c3e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403587b8ad12bc4c56015f98a22a457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a1403587b8ad12bc4c56015f98a22a457">apply</a> (Vtype &amp;V)</td></tr>
<tr class="separator:a1403587b8ad12bc4c56015f98a22a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04178f8e9a3908f72788305c45fe80db"><td class="memItemLeft" align="right" valign="top"><a id="a04178f8e9a3908f72788305c45fe80db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>apply</b> (std::vector&lt; Vtype &gt; &amp;Varray)</td></tr>
<tr class="separator:a04178f8e9a3908f72788305c45fe80db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c7260ba64a517269d30ac401f55ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a4e3c7260ba64a517269d30ac401f55ee">apply</a> (const Vtype &amp;Vin, Vtype &amp;Vout) const</td></tr>
<tr class="separator:a4e3c7260ba64a517269d30ac401f55ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc588437d7ccb042ea5fad65f7892c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#acc588437d7ccb042ea5fad65f7892c72">apply</a> (const std::vector&lt; double &gt; &amp;Vin, std::vector&lt; double &gt; &amp;Vout) const</td></tr>
<tr class="separator:acc588437d7ccb042ea5fad65f7892c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6328ff35ee1ee01397fad6d50aad4705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a6328ff35ee1ee01397fad6d50aad4705">applyTranspose</a> (Vtype &amp;V)</td></tr>
<tr class="separator:a6328ff35ee1ee01397fad6d50aad4705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610f08db14f4e3c99963838f06282ad9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a610f08db14f4e3c99963838f06282ad9">applyTranspose</a> (const Vtype &amp;Vin, Vtype &amp;Vout) const</td></tr>
<tr class="separator:a610f08db14f4e3c99963838f06282ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3215af8bfb73fe6c10b225112b616b54"><td class="memItemLeft" align="right" valign="top"><a id="a3215af8bfb73fe6c10b225112b616b54"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>getRowDimension</b> () const</td></tr>
<tr class="separator:a3215af8bfb73fe6c10b225112b616b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264ab86463b83d46c75157ecf6ea2b2d"><td class="memItemLeft" align="right" valign="top"><a id="a264ab86463b83d46c75157ecf6ea2b2d"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>getColDimension</b> () const</td></tr>
<tr class="separator:a264ab86463b83d46c75157ecf6ea2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b27becf205f179326d3ab431edecb"><td class="memItemLeft" align="right" valign="top"><a id="a2f1b27becf205f179326d3ab431edecb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isNull</b> ()</td></tr>
<tr class="separator:a2f1b27becf205f179326d3ab431edecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810f36650a38128afc871d85647e181b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a810f36650a38128afc871d85647e181b">getTotalDataCount</a> () const</td></tr>
<tr class="separator:a810f36650a38128afc871d85647e181b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075767d69187872bfa7970f92fb32695"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a075767d69187872bfa7970f92fb32695">getTotalDroppedCount</a> () const</td></tr>
<tr class="separator:a075767d69187872bfa7970f92fb32695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5da28c7fd7b46ad71c64af55ae6f0c2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ad5da28c7fd7b46ad71c64af55ae6f0c2">getTotalInitialCount</a> () const</td></tr>
<tr class="separator:ad5da28c7fd7b46ad71c64af55ae6f0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaed2120a9e4f347f80b9e181e0445c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a6aaed2120a9e4f347f80b9e181e0445c">printMatrix</a> (std::string format=&quot;%10.5e&quot;) const</td></tr>
<tr class="separator:a6aaed2120a9e4f347f80b9e181e0445c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef87b92146a2a58a294ba13896d941b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#aef87b92146a2a58a294ba13896d941b6">operator=</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:aef87b92146a2a58a294ba13896d941b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f8fe61b6d5b5686dc68654d1d31a6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a12f8fe61b6d5b5686dc68654d1d31a6c">operator+=</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:a12f8fe61b6d5b5686dc68654d1d31a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12d033124ca550b957fa90b17b3cc9a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ad12d033124ca550b957fa90b17b3cc9a">operator+</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;rhs) const</td></tr>
<tr class="separator:ad12d033124ca550b957fa90b17b3cc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e41591ad6dc298d72de24f59fd75bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ac3e41591ad6dc298d72de24f59fd75bd">operator*=</a> (const double a)</td></tr>
<tr class="separator:ac3e41591ad6dc298d72de24f59fd75bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5411bec1a96c02453da36c371a782011"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a5411bec1a96c02453da36c371a782011">operator*</a> (const double a)</td></tr>
<tr class="separator:a5411bec1a96c02453da36c371a782011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f51c6b3a2ca0d79767f25a9ad89d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ad5f51c6b3a2ca0d79767f25a9ad89d66">operator-=</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:ad5f51c6b3a2ca0d79767f25a9ad89d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e49687e86d272ca3139f965477bd17"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a17e49687e86d272ca3139f965477bd17">operator-</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;rhs) const</td></tr>
<tr class="separator:a17e49687e86d272ca3139f965477bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736abe6e2bd3c7c8f65a291892f8b9a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a736abe6e2bd3c7c8f65a291892f8b9a5">operator*=</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;rhs)</td></tr>
<tr class="separator:a736abe6e2bd3c7c8f65a291892f8b9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2992f5bd0e9134f5550f3c4c5458888f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a2992f5bd0e9134f5550f3c4c5458888f">operator*</a> (const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;rhs) const</td></tr>
<tr class="separator:a2992f5bd0e9134f5550f3c4c5458888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccaa796de382daf3f37b552a6bfbb01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a7ccaa796de382daf3f37b552a6bfbb01">createTranspose</a> (<a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;S) const</td></tr>
<tr class="separator:a7ccaa796de382daf3f37b552a6bfbb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d15b414cbba3c59a54dde197d2fb8"><td class="memItemLeft" align="right" valign="top"><a id="a169d15b414cbba3c59a54dde197d2fb8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSymmetric</b> (double relTol=1.0e-15)</td></tr>
<tr class="separator:a169d15b414cbba3c59a54dde197d2fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a1b20250dd291a32e328acd004d9e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ab8a1b20250dd291a32e328acd004d9e5">createLowerTriComponent</a> (<a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;L)</td></tr>
<tr class="separator:ab8a1b20250dd291a32e328acd004d9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40e88211eb32c7e191cda8b0bf9c0e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#aa40e88211eb32c7e191cda8b0bf9c0e4">createUpperTriComponent</a> (<a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;U)</td></tr>
<tr class="separator:aa40e88211eb32c7e191cda8b0bf9c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2795bfc3c033e523e5d87ddd8292a98b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a2795bfc3c033e523e5d87ddd8292a98b">createDiagComponent</a> (<a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;D)</td></tr>
<tr class="separator:a2795bfc3c033e523e5d87ddd8292a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7273daef9cbfb8997881874fc8b4ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#afd7273daef9cbfb8997881874fc8b4ce">applyLowerTriInverse</a> (Vtype &amp;V)</td></tr>
<tr class="separator:afd7273daef9cbfb8997881874fc8b4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f8c80b243e42151919ddd3784f40d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#ad9f8c80b243e42151919ddd3784f40d6">applyUpperTriInverse</a> (Vtype &amp;V)</td></tr>
<tr class="separator:ad9f8c80b243e42151919ddd3784f40d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3959ae4757f28c31df6d1ae6d3737b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#aef3959ae4757f28c31df6d1ae6d3737b">sortColumnIndices</a> ()</td></tr>
<tr class="separator:aef3959ae4757f28c31df6d1ae6d3737b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903632a5e90755870002dc6ec521a64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a903632a5e90755870002dc6ec521a64e">compact</a> ()</td></tr>
<tr class="separator:a903632a5e90755870002dc6ec521a64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f980ef6a29f403fc9558d48ec8598f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#af1f980ef6a29f403fc9558d48ec8598f">printMatrixStructure</a> () const</td></tr>
<tr class="separator:af1f980ef6a29f403fc9558d48ec8598f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ac3fc08e6a07f8f28e00e2f765cf8f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a03ac3fc08e6a07f8f28e00e2f765cf8f">getInitialRowSize</a> () const</td></tr>
<tr class="separator:a03ac3fc08e6a07f8f28e00e2f765cf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4080aeb135f237e28d63cfc2fd1365"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#afb4080aeb135f237e28d63cfc2fd1365">getRowExpansionFactor</a> () const</td></tr>
<tr class="separator:afb4080aeb135f237e28d63cfc2fd1365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bc15282f9326ed91420f8eb2ffa7d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a88bc15282f9326ed91420f8eb2ffa7d5">getOperatorAsDenseMatrix</a> (double *S) const</td></tr>
<tr class="separator:a88bc15282f9326ed91420f8eb2ffa7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef10e70f872b7849413ee720b79e116d"><td class="memItemLeft" align="right" valign="top"><a id="aef10e70f872b7849413ee720b79e116d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resizeRow</b> (long rowIndex)</td></tr>
<tr class="separator:aef10e70f872b7849413ee720b79e116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d1a9212bc495f0108fa7bc1bd029e9"><td class="memItemLeft" align="right" valign="top"><a id="ab3d1a9212bc495f0108fa7bc1bd029e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sortWithData</b> (long *indexVals, double *coeffVals, long n) const</td></tr>
<tr class="separator:ab3d1a9212bc495f0108fa7bc1bd029e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af908fd1a4ec14d555caee537ca3b933f"><td class="memItemLeft" align="right" valign="top"><a id="af908fd1a4ec14d555caee537ca3b933f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>boundsCheck</b> (long, long, long, int) const</td></tr>
<tr class="separator:af908fd1a4ec14d555caee537ca3b933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfe4385596379cce0caa7190ce8ca41"><td class="memItemLeft" align="right" valign="top"><a id="addfe4385596379cce0caa7190ce8ca41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>matrixVectorDimCheck</b> (long aRow, long aCol, long bRow, long bCol) const</td></tr>
<tr class="separator:addfe4385596379cce0caa7190ce8ca41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3a2be0cfeb755a216f48c99f5b87c9"><td class="memItemLeft" align="right" valign="top"><a id="a0c3a2be0cfeb755a216f48c99f5b87c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>matrixMultDimCheck</b> (long aRow, long aCol, long bRow, long bCol) const</td></tr>
<tr class="separator:a0c3a2be0cfeb755a216f48c99f5b87c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af037b0951d3a199b3fcad785d2e50e40"><td class="memItemLeft" align="right" valign="top"><a id="af037b0951d3a199b3fcad785d2e50e40"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>matrixSumDimCheck</b> (long aRow, long aCol, long bRow, long bCol) const</td></tr>
<tr class="separator:af037b0951d3a199b3fcad785d2e50e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a64da4ce0198535fe90d83897cf5e2"><td class="memItemLeft" align="right" valign="top"><a id="a14a64da4ce0198535fe90d83897cf5e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroyData</b> ()</td></tr>
<tr class="separator:a14a64da4ce0198535fe90d83897cf5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afadad1e4f697585bef2c82452d39064a"><td class="memItemLeft" align="right" valign="top"><a id="afadad1e4f697585bef2c82452d39064a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>dropTol</b></td></tr>
<tr class="separator:afadad1e4f697585bef2c82452d39064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59da08e81d82a43b15aad428179e5e4b"><td class="memItemLeft" align="right" valign="top"><a id="a59da08e81d82a43b15aad428179e5e4b"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>initialRowSize</b></td></tr>
<tr class="separator:a59da08e81d82a43b15aad428179e5e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2a80910e35335f6e2115af6addf230"><td class="memItemLeft" align="right" valign="top"><a id="a3e2a80910e35335f6e2115af6addf230"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>rowExpansionFactor</b></td></tr>
<tr class="separator:a3e2a80910e35335f6e2115af6addf230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97a00938e7efe3007241c32de06cd3a"><td class="memItemLeft" align="right" valign="top"><a id="ad97a00938e7efe3007241c32de06cd3a"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>rowCount</b></td></tr>
<tr class="separator:ad97a00938e7efe3007241c32de06cd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd42cde0f710b34f7b2891158c44e01"><td class="memItemLeft" align="right" valign="top"><a id="aefd42cde0f710b34f7b2891158c44e01"></a>
long *&#160;</td><td class="memItemRight" valign="bottom"><b>rowSizes</b></td></tr>
<tr class="separator:aefd42cde0f710b34f7b2891158c44e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4b2a73e5cd5e77d8a7a231a905aea3"><td class="memItemLeft" align="right" valign="top"><a id="aff4b2a73e5cd5e77d8a7a231a905aea3"></a>
long *&#160;</td><td class="memItemRight" valign="bottom"><b>rowFilledSizes</b></td></tr>
<tr class="separator:aff4b2a73e5cd5e77d8a7a231a905aea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9223453e1a015b8d41b35fddcb4ecd"><td class="memItemLeft" align="right" valign="top"><a id="a5e9223453e1a015b8d41b35fddcb4ecd"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>colCount</b></td></tr>
<tr class="separator:a5e9223453e1a015b8d41b35fddcb4ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfa5712d24c5403a169b76eea722f77"><td class="memItemLeft" align="right" valign="top"><a id="aacfa5712d24c5403a169b76eea722f77"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>totalDataCount</b></td></tr>
<tr class="separator:aacfa5712d24c5403a169b76eea722f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69582e7eac06de7c029ba032dc399356"><td class="memItemLeft" align="right" valign="top"><a id="a69582e7eac06de7c029ba032dc399356"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>totalInitialCount</b></td></tr>
<tr class="separator:a69582e7eac06de7c029ba032dc399356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada423a0e37fee5745ecb7f6fe5ee65aa"><td class="memItemLeft" align="right" valign="top"><a id="ada423a0e37fee5745ecb7f6fe5ee65aa"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>totalDroppedCount</b></td></tr>
<tr class="separator:ada423a0e37fee5745ecb7f6fe5ee65aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df86834f33684564824f7cad47ec76d"><td class="memItemLeft" align="right" valign="top"><a id="a1df86834f33684564824f7cad47ec76d"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>coeffValues</b></td></tr>
<tr class="separator:a1df86834f33684564824f7cad47ec76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac697151c59c98337cb76e07832e153dd"><td class="memItemLeft" align="right" valign="top"><a id="ac697151c59c98337cb76e07832e153dd"></a>
long **&#160;</td><td class="memItemRight" valign="bottom"><b>coeffColIndex</b></td></tr>
<tr class="separator:ac697151c59c98337cb76e07832e153dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370fe807443f5f706079e1d02a011d86"><td class="memItemLeft" align="right" valign="top"><a id="a370fe807443f5f706079e1d02a011d86"></a>
Vtype&#160;</td><td class="memItemRight" valign="bottom"><b>vTmp</b></td></tr>
<tr class="separator:a370fe807443f5f706079e1d02a011d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037ead9aa2e4de11f50acf8c22f69d27"><td class="memItemLeft" align="right" valign="top"><a id="a037ead9aa2e4de11f50acf8c22f69d27"></a>
std::vector&lt; Vtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vArrayTmp</b></td></tr>
<tr class="separator:a037ead9aa2e4de11f50acf8c22f69d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3ddce3d84f3bd618ac03004ecb876"><td class="memItemLeft" align="right" valign="top"><a id="ac0c3ddce3d84f3bd618ac03004ecb876"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rowIndexCache</b></td></tr>
<tr class="separator:ac0c3ddce3d84f3bd618ac03004ecb876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a381bf1c2f93f21127e3c059118731"><td class="memItemLeft" align="right" valign="top"><a id="af5a381bf1c2f93f21127e3c059118731"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>repackFlag</b></td></tr>
<tr class="separator:af5a381bf1c2f93f21127e3c059118731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0a5df52b1241d98efc2196b6571df336"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_c_c_1_1_sparse_op.html#a0a5df52b1241d98efc2196b6571df336">operator*</a> (const double a, const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> &amp;X)</td></tr>
<tr class="separator:a0a5df52b1241d98efc2196b6571df336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Vtype&gt;<br />
class SCC::SparseOp&lt; Vtype &gt;</h3>

<p>Sparse matrix representation of finite dimensional linear operators. </p>
<p>This is not a general sparse matrix class, and it's primary purpose is to collect the non-zero entries of a matrix representation of the operator in such a way that the application of the operator to a one dimensional vector is carried out in a computationally efficient manner with minimal storage requirements.</p>
<p>This class is templated with respect to a vector class <b>Vtype</b>.</p>
<p><b>Vtype</b> is a singly indexed vector class with (minimally) the following member functions:</p>
<pre>
Vtype()                            (null constructor)
initialize(const Vtype&amp;)           (copy initializer)
operator =                         (duplicate assignment)
long getSize()                     (Returns the size (dimension) of the vector)
</pre><p>Usage Notes:</p>
<p>!!! Indexing starts at 0 for each matrix entry !!!</p>
<p>Each row is repacked to an array of minimal size when consecutive calls to operator()(i,j) or setOperatorData(...) are called with row indices that differ. To avoid extraneous copying due to repacking, one should loop through the data assignment with the second index running the fastest, for example if S is the <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> instance then</p>
<pre>
for(i = 0; i &lt; N; i++)
{
for(j = 0; j &lt; N; j++)
{
  value =  *** computation of value ***</pre><pre>  S(i,j) = value;
}}
</pre><p>To improve performance by reducing the memory size and increasing locality of memory access, the member function <a class="el" href="class_s_c_c_1_1_sparse_op.html#a903632a5e90755870002dc6ec521a64e">compact()</a> can be called followed by <a class="el" href="class_s_c_c_1_1_sparse_op.html#aef3959ae4757f28c31df6d1ae6d3737b">sortColumnIndices()</a>. This combination of calls requires O(M) operations where M is the number of non-zero entries in the matrix.</p>
<dl class="section author"><dt>Author</dt><dd>Chris Anderson (UCLA) Created for Math 270C from A fork of RC_SparseOp.h created by C. Anderson and R. Compton. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>4/22/15 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>4.20.2016 </dd></dl>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00110">110</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01ca58371ec3964c4d6dcc3859762c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ca58371ec3964c4d6dcc3859762c14">&#9670;&nbsp;</a></span>SparseOp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::<a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Create a duplicate instance. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00139">139</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a8418fd46311c8bbb3162c8e10b1169ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8418fd46311c8bbb3162c8e10b1169ad">&#9670;&nbsp;</a></span>SparseOp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::<a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00168">168</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a3ff49d597cf2083f4f60ba5d29fb3380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff49d597cf2083f4f60ba5d29fb3380">&#9670;&nbsp;</a></span>SparseOp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::<a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialRowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rowExpansionFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. initialRowSize is an estimated number of non-zero elements per row. rowExpansionFactor, is the multiplicative factor used to increase row storage, when the the allocated storage for a particular row is exceeded.</p>
<p>If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00191">191</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acc588437d7ccb042ea5fad65f7892c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc588437d7ccb042ea5fad65f7892c72">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A convenience method to allow working with std::vector&lt;double&gt; vectors. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00698">698</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a4e3c7260ba64a517269d30ac401f55ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3c7260ba64a517269d30ac401f55ee">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites Vout with the values of S*Vin where S is this sparse operator instance.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00678">678</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a1403587b8ad12bc4c56015f98a22a457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1403587b8ad12bc4c56015f98a22a457">&#9670;&nbsp;</a></span>apply() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the values of S*V where S is this sparse operator instance. The row and column dimensions of S must be equal.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00633">633</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="afd7273daef9cbfb8997881874fc8b4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7273daef9cbfb8997881874fc8b4ce">&#9670;&nbsp;</a></span>applyLowerTriInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::applyLowerTriInverse </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the solution of the linear system associated with the lower triangular part of S that includes the diagonal. The values in the upper triangular part of S, excluding the diagonal, are ignored.</p>
<p>This method assumes that all diagonals of the matrix are non-zero.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01226">1226</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a610f08db14f4e3c99963838f06282ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610f08db14f4e3c99963838f06282ad9">&#9670;&nbsp;</a></span>applyTranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::applyTranspose </td>
          <td>(</td>
          <td class="paramtype">const Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>Vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the vector instance Vout with the values of (transpose S)*Vin where S is this sparse operator instance.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00746">746</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a6328ff35ee1ee01397fad6d50aad4705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6328ff35ee1ee01397fad6d50aad4705">&#9670;&nbsp;</a></span>applyTranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::applyTranspose </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the values of (transpose S)*V where S is this sparse operator instance. The row and column dimensions of S must be equal.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00719">719</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ad9f8c80b243e42151919ddd3784f40d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f8c80b243e42151919ddd3784f40d6">&#9670;&nbsp;</a></span>applyUpperTriInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::applyUpperTriInverse </td>
          <td>(</td>
          <td class="paramtype">Vtype &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method overwrites the input vector instance V with the solution of the linear system associated with the upper triangular part of S that includes the diagonal. The values in the lower triangular part of S, excluding the diagonal, are ignored.</p>
<p>This method assumes that all diagonals of the matrix are non-zero.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01274">1274</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a356ea3d7ee3a49823210af278eccfa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356ea3d7ee3a49823210af278eccfa44">&#9670;&nbsp;</a></span>assumedUniqueSetOperatorData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::assumedUniqueSetOperatorData </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coeffValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies the value of of the (rowIndex,colIndex) element of the matrix. This routine does not check if an existing element exists before insertion. Any collection of invocations must consist of unique (i,j) pairs.</p>
<p>This method exists because insertion without having to check for existing elements can save a great deal of time in matrix assembly. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00361">361</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a903632a5e90755870002dc6ec521a64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903632a5e90755870002dc6ec521a64e">&#9670;&nbsp;</a></span>compact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This routine removes extraneous data that has been pre-allocated for each row. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01332">1332</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a2795bfc3c033e523e5d87ddd8292a98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2795bfc3c033e523e5d87ddd8292a98b">&#9670;&nbsp;</a></span>createDiagComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::createDiagComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> argument with the diagonal component of the invoking instance, e.g. e.g. the D part of the decomposition A = L + D + U </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01196">1196</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ab8a1b20250dd291a32e328acd004d9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a1b20250dd291a32e328acd004d9e5">&#9670;&nbsp;</a></span>createLowerTriComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::createLowerTriComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> argument with the lower triangular component of the invoking instance, e.g. e.g. the L part of the decomposition A = L + D + U</p>
<p>The diagonal is NOT included, </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01146">1146</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a7ccaa796de382daf3f37b552a6bfbb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccaa796de382daf3f37b552a6bfbb01">&#9670;&nbsp;</a></span>createTranspose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::createTranspose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> argument with the transpose of the invoking instance. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01042">1042</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="aa40e88211eb32c7e191cda8b0bf9c0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40e88211eb32c7e191cda8b0bf9c0e4">&#9670;&nbsp;</a></span>createUpperTriComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::createUpperTriComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method initializes the input <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> argument with the upper triangular component of the invoking instance, e.g. e.g. the U part of the decomposition A = L + D + U</p>
<p>The diagonal is NOT included, </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01171">1171</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a03ac3fc08e6a07f8f28e00e2f765cf8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ac3fc08e6a07f8f28e00e2f765cf8f">&#9670;&nbsp;</a></span>getInitialRowSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::getInitialRowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the initial estimate of the number of non-zero elements per row. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01371">1371</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a88bc15282f9326ed91420f8eb2ffa7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bc15282f9326ed91420f8eb2ffa7d5">&#9670;&nbsp;</a></span>getOperatorAsDenseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::getOperatorAsDenseMatrix </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A low level utility routine to extract the matrix data as a singly indexed double array. This routine packs a double array S with the values of the dense matrix representation of the operator. The data is stored by rows (C convention).</p>
<p>The input argument S is a pointer to an existing double array of size rowCount*colCount.</p>
<p>The (i,j)th element of the dense matrix can be accessed using</p>
<pre>
Sij =  S[j+ i*colCount]
</pre> 
<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01392">1392</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="afb4080aeb135f237e28d63cfc2fd1365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4080aeb135f237e28d63cfc2fd1365">&#9670;&nbsp;</a></span>getRowExpansionFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::getRowExpansionFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the multiplicative factor when the storage from a given row must be re-allocated. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01376">1376</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a810f36650a38128afc871d85647e181b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810f36650a38128afc871d85647e181b">&#9670;&nbsp;</a></span>getTotalDataCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::getTotalDataCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of non-zero elements in the matrix </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00781">781</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a075767d69187872bfa7970f92fb32695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075767d69187872bfa7970f92fb32695">&#9670;&nbsp;</a></span>getTotalDroppedCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::getTotalDroppedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of non-zero elements that were ignored </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00786">786</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ad5da28c7fd7b46ad71c64af55ae6f0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5da28c7fd7b46ad71c64af55ae6f0c2">&#9670;&nbsp;</a></span>getTotalInitialCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::getTotalInitialCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of calls to the setOperatorData(...) member function. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00793">793</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="afd4831fb0ad84a6c7fb584cbc244c1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4831fb0ad84a6c7fb584cbc244c1b7">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Null initializer. All allocated memory is freed. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00214">214</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a2e0a4d9e56c38c04c8c5e5b36fdf118b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0a4d9e56c38c04c8c5e5b36fdf118b">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy initializer. Initializes a duplicate instance. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00240">240</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ac10af7915f2a748a77805ede9690e821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10af7915f2a748a77805ede9690e821">&#9670;&nbsp;</a></span>initialize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00294">294</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="aa551d2cdbb27e5bb74a71cbf67583489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa551d2cdbb27e5bb74a71cbf67583489">&#9670;&nbsp;</a></span>initialize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>initialRowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rowExpansionFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dropTolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize an empty sparse representation of sparse matrix of size rowDimension X colDimension. initialRowSize is an estimated number of non-zero elements per row. rowExpansionFactor, is the multiplicative factor used to increase row storage, when the the allocated storage for a particular row is exceeded.</p>
<p>If a non-zero dropTolerance value is specified any element specified with an absolute value less dropTolerance is ignored.</p>
<pre>
abs(coeffValue) &lt; dropTolerance
</pre><p> e.g. the value is ignored. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00315">315</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="aa257b6414b35a3a8f44a03c85e656db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa257b6414b35a3a8f44a03c85e656db9">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a> <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When used to extract the (i,j)th element, the <a class="el" href="class_s_c_c_1_1_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a> value returned is automatically converted to the (i,j)th value of the <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> matrix. If the (i,j)th element of the <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> instance has not been set, then the <a class="el" href="class_s_c_c_1_1_sparse_op_1_1_sparse_op_ref.html">SparseOpRef</a> is converted to the value 0.0.</p>
<p>When used to assign the (i,j)th element, this member function sets the (i,j)th element to the specified value.</p>
<p>If _DEBUG is defined then index bounds checking is performed. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00607">607</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a5411bec1a96c02453da36c371a782011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5411bec1a96c02453da36c371a782011">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00932">932</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a2992f5bd0e9134f5550f3c4c5458888f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2992f5bd0e9134f5550f3c4c5458888f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (matrix) product of two <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> instances.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01027">1027</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ac3e41591ad6dc298d72de24f59fd75bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e41591ad6dc298d72de24f59fd75bd">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Incremental scalar multiplication </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00903">903</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a736abe6e2bd3c7c8f65a291892f8b9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736abe6e2bd3c7c8f65a291892f8b9a5">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the incremental (matrix) product.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00992">992</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ad12d033124ca550b957fa90b17b3cc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12d033124ca550b957fa90b17b3cc9a">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns sum of <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> instances.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00890">890</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a12f8fe61b6d5b5686dc68654d1d31a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f8fe61b6d5b5686dc68654d1d31a6c">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Incremental sum.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00858">858</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a17e49687e86d272ca3139f965477bd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e49687e86d272ca3139f965477bd17">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the difference of two <a class="el" href="class_s_c_c_1_1_sparse_op.html" title="Sparse matrix representation of finite dimensional linear operators.">SparseOp</a> instances.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00977">977</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ad5f51c6b3a2ca0d79767f25a9ad89d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f51c6b3a2ca0d79767f25a9ad89d66">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the incremental difference.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00945">945</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="aef87b92146a2a58a294ba13896d941b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef87b92146a2a58a294ba13896d941b6">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&amp; <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The left hand side is initialized with the values of the right hand side. If the left hand side is a null instance, then the left hand is initialized as a duplicate.</p>
<p>If _DEBUG is defined then the required dimensional compatibility is checked when the left hand side is a non-null instance. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00838">838</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="a6aaed2120a9e4f347f80b9e181e0445c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aaed2120a9e4f347f80b9e181e0445c">&#9670;&nbsp;</a></span>printMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::printMatrix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;%10.5e&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Displays the matrix to the console. The optional input format string specifies the format of a single entry using C printf output conventions. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00801">801</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="af1f980ef6a29f403fc9558d48ec8598f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f980ef6a29f403fc9558d48ec8598f">&#9670;&nbsp;</a></span>printMatrixStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::printMatrixStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A routine that displays the structure of the matrix as a collection of "+" for non-zero values and "-" for zero values. Due to the aspect ratio of display screens, the display of a square matrix will not be square. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01349">1349</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="ab32ee661ce89c4d6cc0e91c05133fced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32ee661ce89c4d6cc0e91c05133fced">&#9670;&nbsp;</a></span>setOperatorData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::setOperatorData </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coeffValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies the value of of the (rowIndex,colIndex) element of the matrix. Any existing value is overwritten. If a non-zero value of dropTolerance is specified, then this operator is a no-op when </p><pre>
abs(coeffValue) &lt; dropTolerance
</pre><p> e.g. the value is ignored. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00416">416</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<a id="aef3959ae4757f28c31df6d1ae6d3737b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3959ae4757f28c31df6d1ae6d3737b">&#9670;&nbsp;</a></span>sortColumnIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_s_c_c_1_1_sparse_op.html">SCC::SparseOp</a>&lt; Vtype &gt;::sortColumnIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This routine sorts the elements of each row so that the list of column indices associated with each non-zero element in each row are in increasing order. </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l01314">1314</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0a5df52b1241d98efc2196b6571df336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5df52b1241d98efc2196b6571df336">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_c_c_1_1_sparse_op.html">SparseOp</a>&lt; Vtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication </p>

<p class="definition">Definition at line <a class="el" href="_s_c_c___sparse_op_8h_source.html#l00920">920</a> of file <a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SparseOp/<a class="el" href="_s_c_c___sparse_op_8h_source.html">SCC_SparseOp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 30 2024 13:13:08 for 270C_Support by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
